#!/usr/bin/env bash

###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################

###################################################################
# Constants
###################################################################

readonly SIGMA=2.35482004503
readonly POSINT='^[0-9]+$'





###################################################################
###################################################################
# BEGIN GENERAL MODULE HEADER
###################################################################
###################################################################
# Read in:
#  * path to localised design file
#  * overall context in pipeline
#  * whether to explicitly trace all commands
# Trace status is, by default, set to 0 (no trace)
###################################################################
trace=0
while getopts "d:c:t:" OPTION
   do
   case $OPTION in
   d)
      design_local=${OPTARG}
      ;;
   c)
      cxt=${OPTARG}
      ! [[ ${cxt} =~ $POSINT ]] && ${XCPEDIR}/xcpModusage mod && exit
      ;;
   t)
      trace=${OPTARG}
      if [[ ${trace} != "0" ]] && [[ ${trace} != "1" ]]
         then
         ${XCPEDIR}/xcpModusage mod
         exit
      fi
      ;;
   *)
      echo "Option not recognised: ${OPTARG}"
      ${XCPEDIR}/xcpModusage mod
      exit
   esac
done
shift $((OPTIND-1))
###################################################################
# Ensure that the compulsory design_local variable has been defined
###################################################################
[[ -z ${design_local} ]] && ${XCPEDIR}/xcpModusage mod && exit
###################################################################
# Set trace status, if applicable
# If trace is set to 1, then all commands called by the pipeline
# will be echoed back in the log file.
###################################################################
[[ ${trace} == "1" ]] && set -x
###################################################################
# Initialise the module.
###################################################################
echo ""; echo ""; echo ""
echo "###################################################################"
echo "#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #"
echo "#                                                                 #"
echo "#  ☭             EXECUTING TASK ACTIVATION MODULE              ☭  #"
echo "#                                                                 #"
echo "#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #"
echo "###################################################################"
echo ""
###################################################################
# Source the design file.
###################################################################
source ${design_local}
###################################################################
# Create a directory for intermediate outputs.
###################################################################
[[ ${NUMOUT} == 1 ]] && prep=${cxt}_
outdir=${out}/${prep}task
[[ ! -e ${outdir} ]] && mkdir -p ${outdir}
echo "Output directory is $outdir"
###################################################################
# Define paths to all potential outputs.

# For the task module, potential outputs include:
#  * dsnmat : The design matrix, generated by concatenating all
#    models, convolving them with a haemodynamic response
#    function, and filtering.
#  * confmat : The confound matrix following filtering.
#  * final : The final output of the module, indicating its
#    successful completion.
###################################################################



###################################################################
# * Initialise a pointer to the image.
# * Ensure that the pointer references an image, and not something
#   else such as a design file.
# * On the basis of this, define the image extension to be used for
#   this module (for operations, such as AFNI, that require an
#   extension).
# * Localise the image using a symlink, if applicable.
# * Define the base output path for intermediate files.
###################################################################
img=${out}/${prefix}
imgpath=$(ls ${img}.*)
for i in ${imgpath}
   do
   [[ $(imtest ${i}) == 1 ]] && imgpath=${i} && break
done
ext=$(echo ${imgpath}|sed s@${img}@@g)
[[ ${ext} == ".nii.gz" ]] && export FSLOUTPUTTYPE=NIFTI_GZ
[[ ${ext} == ".nii" ]] && export FSLOUTPUTTYPE=NIFTI
[[ ${ext} == ".hdr" ]] && export FSLOUTPUTTYPE=NIFTI_PAIR
[[ ${ext} == ".img" ]] && export FSLOUTPUTTYPE=NIFTI_PAIR
[[ ${ext} == ".hdr.gz" ]] && export FSLOUTPUTTYPE=NIFTI_PAIR_GZ
[[ ${ext} == ".img.gz" ]] && export FSLOUTPUTTYPE=NIFTI_PAIR_GZ
img=${outdir}/${prefix}~TEMP~
if [[ $(imtest ${img}) != "1" ]] \
   || [[ "${regress_rerun[${cxt}]}" == "Y" ]]
   then
   rm -f ${img}
   ln -s ${out}/${prefix}${ext} ${img}${ext}
fi
imgpath=$(ls ${img}${ext})
###################################################################
# Prime the localised design file so that any outputs from this
# module appear beneath the correct header.
###################################################################
echo "" >> $design_local
echo "# *** outputs from task[${cxt}] *** #" >> $design_local
echo "" >> $design_local
###################################################################
# Verify that the module should be run:
#  * Test whether the final output already exists.
#  * Determine whether the user requested the module to be re-run.
# If it is determined that the module should not be run, then any
#  outputs must be written to the local design file.
###################################################################



###################################################################
###################################################################
# END GENERAL MODULE HEADER
###################################################################
###################################################################





task_modeldir
task_dx
task_tunits

task_tmpf
task_hipass
task_lopass
task_order
task_pass
task_ripple
task_ripple2
task_tmpf_dvols

task_ortho

task_contrasts

task_rerun
task_cleanup





###################################################################
# First, generate the design matrix using only the stick models.
###################################################################
if [[ ! -e ${img}design ]] \
   || [[ ${task_rerun[${cxt}]} == Y ]]
   then
   echo ""; echo ""; echo ""
   echo "Current processing step:"
   echo "Preparing design matrix"
   echo " * Model directory: ${task_modeldir[${cxt}]}"
   echo " * Models are in units of ${task_tunits[${cxt}]}"
   echo " * Temporal derivatives included: ${task_dx[${cxt}]}"
   ${XCPEDIR}/utils/stick2lm.R \
      -i ${img}${ext} \
      -s ${task_modeldir[${cxt}]} \
      -d ${task_dx[${cxt}]} \
      -n ${task_tunits[${cxt}]} \
      >> ${img}design
   echo "Processing step complete:"
   echo "Preparing design matrix"
fi





###################################################################
# Next, apply the user-specified filter to the 4D timeseries, the
# design matrix, and any confound matrix.
#
# This is nearly identical to the filtering procedure in the
# regress module. However, the design matrix is also filtered,
# and no fitted signals are removed from the timeseries under
# any circumstances.
#
# Read in any local regressors, if they are present.
###################################################################
if [[ ! -z "${locregs[${subject}]}" ]]
   then
   locregs=$(cat ${locregs[${subject}]})
fi
###################################################################
# Apply a temporal filter to the BOLD timeseries, the confound
# matrix, and any local regressors.
#
# Any timeseries to be used in regression should by now be in
# the confound matrix.
###################################################################
echo ""; echo ""; echo ""
echo "Current processing step:"
echo "Temporally filtering image and design"
echo "${task_tmpf[${cxt}]} filter"
echo "High pass frequency: ${task_hipass[${cxt}]}"
echo "Low pass frequency: ${task_lopass[${cxt}]}"
###################################################################
# If no temporal filtering has been specified by the user, then
# bypass this step.
###################################################################
if [[ ${task_tmpf[${cxt}]} == none ]]
   then
   ln -s ${img}${ext} ${img}_filtered${ext}
   ln -s ${confmat[${subject}]} ${confmat[${cxt}]}
###################################################################
# Ensure that this step has not already run to completion by
# checking for the existence of a filtered image and confound
# matrix.
###################################################################
elif [[ $(imtest ${img}_filtered) != "1" ]] \
   || [[ ! -e ${img}design_filtered ]] \
   || [[ "${task_rerun[${cxt}]}" == "Y" ]]
   then
	################################################################
	# OBTAIN MASKS: SPATIAL
	# Obtain the spatial mask over which filtering is to be
	# applied, if a subject mask has been generated. Otherwise,
	# perform filtering without a mask.
	################################################################
   if [[ $(imtest ${mask[${subject}]}) == "1" ]]
      then
      mask="-m ${mask[${subject}]}"
	################################################################
	# If the module fails to find a mask, then prepare to
	# call tfilter without a mask argument.
	################################################################
   else
      mask=""
   fi
	################################################################
	# OBTAIN MASKS: TEMPORAL
	# Obtain the path to the temporal mask over which filtering is
	# to be executed.
	#
	# At the time of writing, censoring of high-motion epochs is
	# not a common practice in task activation literature. However,
	# the option is there...
	#
	# If iterative censoring has been specified, then it will be
	# necessary to interpolate over high-motion epochs in order to
	# ensure that they do not exert inordinate influence upon the
	# temporal filter, resulting in corruption of adjacent volumes
	# by motion-related variance.
	################################################################
	censor_type=${censor[${subject}]}
	if [[ -e "${tmask[${subject}]}" ]]
      then
      tmaskpath=$(ls -d1 ${tmask[${subject}]})
	else
      tmaskpath=ones
   fi
	################################################################
	# Next, determine whether the user has enabled censoring of
	# high-motion volumes.
	#  * If iterative censoring is enabled, the temporal mask
	#    should be passed to tfilter with the -n flag. This will
	#    enable interpolation over volumes corrupted by motion.
	#  * If final censoring is enabled, the temporal mask should
	#    be passed to tfilter with the -k flag. This will ensure
	#    that volumes discarded from the BOLD timeseries are also
	#    discarded from the temporal mask, but will not interpolate
	#    over censored volumes.
	#  * If censoring is enabled, but no temporal mask exists yet,
	#    something has probably not completed as intended. Notify
	#    the user of the situation.
	#  * If censoring is disabled, no additional argument is passed
	#    to tfilter.
	################################################################
	if [[ "${censor_type}" == "iter" ]] \
	   && [[ ${tmaskpath} != ones ]]
	   then
	   tmask="-n ${tmaskpath}"
	elif [[ "${censor_type}" == "final" ]] \
	   && [[ ${tmaskpath} != ones ]]
	   then
	   tmask="-k ${tmaskpath}"
	elif [[ "${censor_type}" != "none" ]]
	   then
	   echo "WARNING: Censoring of high-motion volumes requires a"
	   echo "temporal mask, but the task module has failed"
	   echo "to find one. You are advised to inspect your pipeline"
	   echo "to ensure that this is intentional."
	   echo ""
	   echo "Overriding user input:"
	   echo "No censoring will be performed."
	   censor[${subject}]=none
	   echo "censor[${subject}]=${censor[${subject}]}" \
	      >> ${design_local}
	   tmask=""
	else
	   tmask=""
	fi
	################################################################
	# DERIVATIVE IMAGES AND TIMESERIES
	# (CONFOUND MATRIX AND LOCAL REGRESSORS)
	# Prime the index of derivative images, as well as any 1D
	# timeseries (e.g. realignment parameters) that should be
	# filtered so that they can be used in linear models without
	# reintroducing the frequencies removed from the primary BOLD
	# timeseries.
	################################################################
	derivs=""
	ts1d=""
	[[ -e ${auxImgs[${subject}]} ]] \
	   && derivs="-x ${auxImgs[${subject}]}"
	################################################################
	# ...and the confound matrix
	################################################################
	if [[ -e ${confmat[${subject}]} ]]
	   then
	   ts1d="${img}design,${confmat[${subject}]}"
	fi
	################################################################
	# Replace any whitespace characters in the 1D timeseries list
	# with commas, and prepend the -l flag for input as an argument
	# to tfilter.
	################################################################
	ts1d=$(echo ${ts1d}|sed s@' '@','@g)
	[[ ! -z ${ts1d} ]] && ts1d="-1 ${ts1d}"
	################################################################
	# FILTER-SPECIFIC ARGUMENTS
	# Next, set arguments specific to each filter class.
	################################################################
	tforder=""
	tfdirec=""
	tfprip=""
	tfsrip=""
	case ${prestats_tmpf[${cxt}]} in
	butterworth)
	   tforder="-r ${task_tmpf_order[${cxt}]}"
	   tfdirec="-d ${task_tmpf_pass[${cxt}]}"
	   ;;
	chebyshev1)
	   tforder="-r ${task_tmpf_order[${cxt}]}"
	   tfdirec="-d ${task_tmpf_pass[${cxt}]}"
	   tfprip="-p ${task_tmpf_ripple[${cxt}]}"
	   ;;
	chebyshev2)
	   tforder="-r ${task_tmpf_order[${cxt}]}"
	   tfdirec="-d ${task_tmpf_pass[${cxt}]}"
	   tfsrip="-s ${task_tmpf_ripple2[${cxt}]}"
	   ;;
	elliptic)
	   tforder="-r ${task_tmpf_order[${cxt}]}"
	   tfdirec="-d ${task_tmpf_pass[${cxt}]}"
	   tfprip="-p ${task_tmpf_ripple[${cxt}]}"
	   tfsrip="-s ${task_tmpf_ripple2[${cxt}]}"
	   ;;
	esac
	################################################################
	# If the user has requested discarding of initial and/or final
	# volumes from the filtered timeseries, the request should be
	# passed to tfilter.
	################################################################
	tfdvol=""
	[[ ! -z ${task_tmpf_dvols[${cxt}]} ]] \
	   && [[ ${task_tmpf_dvols[${cxt}]} != 0 ]] \
	   && tfdvol="-v ${task_tmpf_dvols[${cxt}]}"
	################################################################
	# If the user has requested command tracing, propagate
	# that request into the tfilter routine.
	################################################################
	[[ ${trace} == 1 ]] && trace_prop="-t"
	################################################################
	# Engage the tfilter routine to filter the image.
	#  * This is essentially a wrapper around the three implemented
	#    filtering routines: fslmaths, 3dBandpass, and genfilter
	################################################################
	${XCPEDIR}/utils/tfilter \
      -i ${img} \
      -o ${img}_filtered \
      -f ${task_tmpf[${cxt}]} \
      -h ${task_hipass[${cxt}]} \
      -l ${task_lopass[${cxt}]} \
      ${mask} \
      ${tmask} \
      ${tforder} \
      ${tfdirec} \
      ${tfprip} \
      ${tfsrip} \
      ${tfdvol} \
      ${derivs} \
      ${ts1d} \
      ${trace_prop}
	   #############################################################
	   # Move outputs to target
	   #############################################################
	   [[ -e ${img}_filtered_${prefix}_design.1D ]] \
	      && mv -f ${img}_filtered_${prefix}_design.1D \
	      ${img}design_filtered
	   [[ -e ${img}_filtered_${prefix}_confmat.1D ]] \
	      && mv -f ${img}_filtered_${prefix}_confmat.1D \
	      ${confmat[${cxt}]}
	   [[ -e ${img}_filtered_tmask.1D ]] \
	      && mv -f ${img}_filtered_tmask.1D ${tmask[${cxt}]}
	   [[ -e ${img}_filtered_derivs ]] \
	      && mv -f ${img}_filtered_derivs ${auxImgs[${subject}]}
	fi
fi
###################################################################
# Update image pointer
###################################################################
img=${img}_filtered
echo "Processing step complete: temporal filtering"





###################################################################
# Concatenate the design and confound matrices.
###################################################################





###################################################################
# Apply any requested orthogonalisations to the filtered and
# concatenated matrix, and ensure that the peak-to-peak heights
# in the model are unit.
###################################################################





###################################################################
# Run the general linear model.
###################################################################





###################################################################
# Prepare statistical derivative maps based on the confound
# matrix.
###################################################################
